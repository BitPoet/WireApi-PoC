<?php namespace ProcessWire;


/**
 * ProcessWire API helper class.
 *
 * This is a proof-of-concept implementation for a somewhat unified API endpoint class
 * in ProcessWire.
 *
 * Goals:
 * - Provide a neat routing syntax similar to Laravel Routing
 * - Stick with familiar PW syntax / idioms
 * - Make use of builtin $sanitizer to validate route URLs and part values
 * - Allow handling of routes through functions, methods and PHP files
 *
 * A bit of prose:
 * WireApi registers itself as $api API variable and thus is available as either $api,
 * wire('api') or $this->api inside Wire derived classes.
 *
 * Routes all end in a custom page that calls $api->handleRequest();
 * You can theoretically have multiple API endpoints by creating multiple pages with
 * their own template.
 * A minimal template (e.g. /site/templates/api.php) would look like this:
 * ~~~~~~
 * <?php namespace ProcessWire;
 *
 * $api->handleRequest();
 * ~~~~~~
 *
 * Routes can be attached from almost anywhere, i.e. inside modules, site/ready.php
 * or the endpoint template file itself.
 * At a minimum, a route definition needs the HTTP verb(s) it handles (or 'ALL' as a
 * wildcard) and a handler, which can be a plain function, a class method or any valid
 * callable definition accepted by PHP, or the path to a PHP file, which lets you build
 * your own 'API template folders', e.g. /site/templates/apitemplates/.
 *
 * Examples:
 * ~~~~~~
 * // Simple GET route that populates the URL pattern paremeter 'number' and handles
 * // requests through an anonymous function.
 * $api->route(['GET'], '/api/test/{number}/', function($url, $values) { echo json_encode(['number' => $value['number']]); });
 *
 * // More verbose POST route that populates $values['userid'], handles the request
 * // through the setUserData method of the current class and runs two checks to validate
 * // the path, the first through $sanitizer->unsignedInt, the second through a user defined
 * // function.
 * $api->route(['POST'], '/api/v1/user/{userid}/', $this, 'setUserData')
 *  ->check_unsignedInt('userid')
 *  ->validate(function($url, $route, $check, $values) { return $values['userid'] < 999999; });
 *
 * // Simple GET route using the shorthand method. The output is generated by rendering the
 * // apitemplates/userlist.php file.
 * $api->routeGET('/api/userlist/', 'apitemplates/userlist');
 * ~~~~~~
 *
 */
 
class WireApi extends WireData implements Module {

	public static function getModuleInfo() {
		return [
			'title'			=>	__('API', __FILE__),
			'summary'		=>	__('Provide endpoint routing to expose PW parts through a normalized API', __FILE__),
			'version'		=>	'0.0.6',
			// Assign numeric autoload value to make sure the module gets loaded
			// before any other site modules, so that $api is availabile to them
			// at init() time.
			'autoload'		=>	99,
			'singular'		=>	true,
			'requires'		=>	['PHP>=5.6.0'],
			'permission'	=>	'page-view'
		];
	}
	
	protected $routes;

	public function init() {
		$this->set('debug', false);
		$this->routes = new WireArray();
		$this->wire('api', $this);
	}

	/**
	 * Handle the request. To be called in your api template file, usually
	 * /site/templates/api.php
	 */
	public function ___handleRequest($options = []) {
		if(isset($options['debug']))
			$this->debug = $options['debug'];
		
		$url = substr($this->input->url, strlen($this->urls->root));
		if(substr($url, 0, 1) !== '/')
			$url = '/' . $url;
		
		foreach($this->routes as $route) {
			$this->debugLog(sprintf("Checking URL %s against route %s", $url, $route->path));
			if($route->matches($url) && $route->matchesConstraints($url)) {
				$route->handleRequest($url);
				break;
			} else {
				$this->debugLog(sprintf("Route %s did not match", $route->path));
			}
		}
	}
	
	protected function debugLog($txt) {
		if($this->debug) {
			$this->log->save('api', $txt);
		}
	}
	
	/**
	 * Set appropriate Content-Type header and output the supplied
	 * data in JSON notation. If the argument is already a string,
	 * no JSON conversion will be done, i.e. the string is output
	 * as is.
	 *
	 * @param array|object|string $responseData
	 */
	public function jsonResponse($responseData) {
		header('Content-Type: application/json');
		
		echo is_string($responseData) ? $responseData: wireEncodeJSON($responseData);
	}
	
	public function __call($method, $arguments) {
		if(preg_match('/^route([A-Z]+)$/', $method, $match)) {
			return $this->route([$match[1]], ...$arguments);
		}
		return parent::__call($method, $arguments);
	}
	
	/**
	 * Shorthand for $api->route(['GET'], ...)
	 */
	public function routeGET(...$args) {
		$this->route(['GET'], ...$args);
	}

	/**
	 * Shorthand for $api->route(['POST'], ...)
	 */
	public function routePOST(...$args) {
		$this->route(['POST'], ...$args);
	}
	
	/**
	 * Shorthand for $api->route(['PUT'], ...)
	 */
	public function routePUT(...$args) {
		$this->route(['PUT'], ...$args);
	}

	/**
	 * Shorthand for $api->route(['DELETE'], ...)
	 */
	public function routeDELETE(...$args) {
		$this->route(['DELETE'], ...$args);
	}

	/**
	 * Shorthand for $api->route(['PATCH'], ...)
	 */
	public function routePATCH(...$args) {
		$this->route(['PATCH'], ...$args);
	}

	/**
	 * Shorthand for $api->route(['OPTIONS'], ...)
	 */
	public function routeOPTIONS(...$args) {
		$this->route(['OPTIONS'], ...$args);
	}

	/**
	 * Shorthand for $api->route(['HEAD'], ...)
	 */
	public function routeHEAD(...$args) {
		$this->route(['HEAD'], ...$args);
	}
	
	/**
	 * Shorthand for $api->route(['ALL'], ...)
	 */
	public function routeAll(...$args) {
		$this->route(['ALL'], ...$args);
	}

	/**
	 * Add a route.
	 *
	 * ~~~~~~
	 * # Handle calls to /api/test/NUMBER/ by an inline callback, populate $values['number'] with the third part of the path.
	 * $api->route(['GET'], '/api/test/{number}/', function($url, $values) { echo json_encode(['number' => $value['number']]); });
	 *
	 * # Hand calls to /api/v1/user/NUMBER/ off the setUserData method of the current class.
	 * # Add two checks to the route as well that will be executed in the order they were added.
	 * # check_unsignedInt() uses $sanitizer->unsignedInt.
	 * # validate() uses an inline function here that will be passed the full URL and an assoziative array with all path parameters.
	 * $api->route(['POST'], '/api/v1/user/{userid}/', $this, 'setUserData')
	 *  ->check_unsignedInt('userid')
	 *  ->validate(function($url, $route, $check, $userid) { return $userid < 999999; });
	 *
	 * # The /api/userlist/ route will be rendered by a PHP file. See wireRenderFile for details.
	 * $api->route(['GET'], '/api/userlist/', 'apitemplates/userlist');
	 * ~~~~~~
	 *
	 * @param Array $methods HTTP methods like GET, POST, PUT or 'ALL'.
	 * @param string $path The path pattern, can contain placeholders in curly braces.
	 * @param string|object|callback|null $object The object to call if the handler is a class method. For a regular function, this can also contain the function name.
	 * @param string|callback|null $funcOrMeth The name of the function/method to call. Null if already passed in $object, or a valid callable itself if $object is null. You can also pass a file path in $funcOrMeth or $object, which will be rendered by wireRenderFile. In that case, the file path needs to include a slash.
	 * @param bool $debug Set to true to enable debug output in the handler. Will write to the 'api' log.
	 * @return ApiRoute Returns the route for chained calls.
	 */
	 
	public function ___route($methods, $path, $object, $funcOrMeth = null, $debug = false) {
		
		if($debug) $this->log->save('api', sprintf("route(method=%s, path=%s, object=%s , funcOrMeth=%s, debug=%s)", '['.implode(',',$methods) . ']', $path, $object, $funcOrMeth, $debug));

		$routeType = 'callable';
		
		if($funcOrMeth == null) {
			// Full callable was passed as third argument
			$callable = $object;
		} elseif($object == null) {
			// Full callable was passed as fourth argument
			$callable = $funcOrMeth;
		} else {
			// Callable for class method
			$callable = [$object, $funcOrMeth];
		}

		if(is_string($callable)) {
			if(strpos($callable, '/') !== false) {
				// Rendering a file
				$routeType = 'file';
			} elseif(strpos($callable, 'ProcessWire\\') === false) {
				// If calling a plain method, we need to make sure it is namespaced
				$callable = '\\ProcessWire\\' . $callable;
			}
		}
		
		// Add the new route to the list
		$r = new ApiRoute($methods, $path, $routeType, $callable, $debug);
		$r->id = $this->routes->count();
		$this->routes->append($r);
		
		return $r;
	}

	public function notFound() {
		$this->header404();
		throw new Wire404Exception('404 page not found', Wire404Exception::codeNonexist);		
	}

	protected function header404() {
		static $n = 0;
		if(!$n) header("HTTP/1.1 404 Page Not Found"); 
		$n++;
	}
	
}


/**
 * Invidiual API route.
 *
 * It contains all the data for handling the route if matched and the checks to validate it.
 */
class ApiRoute extends WireData {
	
	protected $debug = false;
	
	public function __construct($methods, $path, $type, $callable, $debug = false) {
		$this->set('methods', $methods);
		$this->set('path', $path);
		$this->set('type', $type);
		$this->set('handler', $callable);
		$this->set('checks', new WireArray());
		$this->set('pathValues', []);
		$this->set('error', '');
		$this->debug = $debug;
	}
	
	protected function debugLog($txt) {
		if($this->debug) {
			$this->log->save('api', $txt);
		}
	}
	
	/**
	 * Handle methods that start with "check_" and convert them to
	 * assignments of Sanitizer methods for checking request URLs.
	 * The "check_" part will be removed, the rest needs to be any
	 * valid method of the Sanitizer class.
	 *
	 * So, e.g. you want to validate the argument "user" against
	 * Sanitizer::intUnsigned, you'd call
	 * $apiHandler->check_intUnsigned('user')
	 *
	 * To validate the full request URL, use the word "url" instead.
	 * Of course, you can't name a field in your URL that way, this
	 * is a served word for that purpose.
	 * $apiHandler->check_match('url', '~^/reports/(daily|monthly)/.*~')
	 */
	public function __call($method, $arguments) {
		if(strpos($method, 'check_') === 0) {
			$sanitizerMethodName = substr($method, 0, 6);
			$field = array_shift($arguments);
			
			$this->checks->add([
				'type'		=> 'santizier',
				'handler'	=> ['Sanitizer', $sanitizerMethodName],
				'field'		=>	$field,
				'args'		=>	$arguments
			]);
			
			return $this;
		}
		
		parent::__call($method, $arguments);
	}


	/**
	 * Attach a custom check function/method to this route.
	 *
	 * @param string|array|object|null $object The class or callable to call, null if providing a plain function in $method.
	 * @param string|null $method The function/method name to call, or null if already provided in $object.
	 * @param array $params Any additional argments to pass to the handler function/method.
	 * @return object $this
	 */
	public function check($object = null, $method = null, $params = []) {
		if($method == null) {
			$handler = $object;
		} elseif($object == null) {
			$handler = $method;
		} else {
			$handler = [$object, $method];
		}
		
		if(is_string($handler) && strpos($handler, 'ProcessWire\\') === false) {
			// Prepend namespace to plain function names
			$handler = '\\ProcessWire\\' . $handler;
		}
		
		$this->checks->add([
			'type'		=>	'custom',
			'handler'	=>	$handler,
			'args'		=>	$params
		]);
		
		return $this;
	}

	/**
	 * Check if request method (GET, POST, ...) and URL path match the this route.
	 */
	public function matches($url) {
		
		$reqMethod = $this->input->requestMethod();
		if($this->methods[0] !== 'ALL' && ! in_array($reqMethod, $this->methods)) {
			$this->debugLog(sprintf('Request method %s not allowed, configured methods: %s', $_SERVER['REQUEST_METHOD'], implode(', ', $this->methods)));
			return false;
		}
		
		$pathPattern = '~' . preg_replace('~\\{[^/}]+\\}~', '[^/]+', $this->path) . '~';
		$ret = preg_match($pathPattern, $url);
		if($ret) {
			$this->debugLog(sprintf("Path %s matches", $this->path));
		} else {
			$this->debugLog(sprintf("Path pattern '%s' does not match url '%s'", $pathPattern, $url));
		}
		return $ret;
	}
	
	protected function checkAndExtractPathPatterns($path, $url) {
		$parts = [];
		$pathParts = explode('/', rtrim($path, '/'));
		$urlParts  = explode('/', rtrim($url, '/'));
		
		if(count($pathParts) !== count($urlParts))
		{
			$this->set('error', $this->_("Pattern depth does not match request URL depth"));
			$this->debugLog(sprintf("Number of path parts (%d) does not match number of url parts (%d)", count($pathParts), count($urlParts)));
			return false;
		}
		
		for($i = 0; $i < count($pathParts); $i++) {
			$pPart = $pathParts[$i];
			$uPart = $urlParts[$i];
			if(substr($pPart, 0, 1) === '{') {
				$pPart = substr($pPart, 1, -1);
				$parts[$pPart] = $uPart;
			}
		}
		
		return $parts;
	}
	
	/**
	 * Handle the current request, invoked by WireApi if pattern and constraits
	 * have matched.
	 *
	 * Executes the configured route handler and passes the current URL and
	 * the populated pattern variables to the handler.
	 */
	public function ___handleRequest($url) {
		$handlerArgs = [$url, $this->pathValues];
		$this->debugLog(sprintf('Calling route handler %s', print_r($this->handler, true)));
		if($this->type === 'file') {
			echo $this->files->render($this->handler, array_merge([
				'url'		=>	$url
			], $this->pathValues));
			return;
		}
		call_user_func_array($this->handler, $handlerArgs);
	}
	
	/**
	 * Check if all constraints for the current route match.
	 */
	public function matchesConstraints($url) {
		$this->pathValues = $this->checkAndExtractPathPatterns($this->path, $url);
		$this->debugLog(sprintf('Extracted path values for route %s: %s', $this->path, json_encode($this->pathValues)));
		
		if(! $this->runChecks($url)) {
			$this->debugLog(sprintf('Not all of %d checks were successful', count($this->checks)));
			return false;
		}
		
		return true;
	}
	
	protected function runChecks($url) {
		
		foreach($this->checks as $check) {
			
			if($check['type'] == 'sanitizer') {

				$checkValue = $check['field'] === 'url' ? $url : $this->pathValues[$check['field']];
				$args = array_merge([$checkValue], $check['args']);

				if($checkValue !== call_user_func_array($check['handler'], $args)) {
					$this->debugLog(sprintf('Constraint of type %s for field %s did not match!', $check['type'], $check['field']));
					return false;
				}
			} elseif($check['type'] == 'custom') {
				$args = [$url, $this, $check, $this->pathValues];
				
				return call_user_func_array($check['handler'], array_merge($args, $check['args']));
			}
		}
		return true;
	}
}
